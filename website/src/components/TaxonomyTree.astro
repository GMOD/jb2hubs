---
interface SpeciesData {
  accession: string
  commonName?: string
  scientificName?: string
  ncbiRefSeqCategory?: string
  suppressed?: boolean
  [key: string]: any
}

interface Props {
  newickData: string
  speciesData?: SpeciesData[]
  header?: string
}

interface TreeNode {
  name?: string
  accession?: string
  children?: TreeNode[]
  branchLength?: number
  parent?: TreeNode
}

interface FlatNodeData {
  id: string
  name?: string
  accession?: string
  branchLength?: number
  children?: FlatNodeData[]
  depth: number
  isLeaf: boolean
}

// Simple Newick parser
function parseNewick(newick: string): TreeNode | null {
  const cleanNewick = newick.trim().replace(/;$/, '')
  if (!cleanNewick) return null

  let index = 0

  function parseNode(): TreeNode {
    const node: TreeNode = { children: [] }

    if (cleanNewick[index] === '(') {
      index++ // skip '('
      do {
        const child = parseNode()
        child.parent = node
        node.children!.push(child)
        if (cleanNewick[index] === ',') {
          index++ // skip ','
        }
      } while (
        cleanNewick[index] === ',' ||
        (cleanNewick[index] !== ')' && index < cleanNewick.length)
      )
      if (cleanNewick[index] === ')') {
        index++ // skip ')'
      }
    }

    // Parse node name
    let name = ''
    while (
      index < cleanNewick.length &&
      cleanNewick[index] !== ',' &&
      cleanNewick[index] !== ')' &&
      cleanNewick[index] !== '(' &&
      cleanNewick[index] !== ':'
    ) {
      name += cleanNewick[index]
      index++
    }

    if (name) {
      const accessionMatch = name.match(/^(.+?)\[([^\]]+)\]$/)
      if (accessionMatch) {
        node.name = accessionMatch[1]
        node.accession = accessionMatch[2]
      } else {
        node.name = name
      }
    }

    // Parse branch length
    if (cleanNewick[index] === ':') {
      index++ // skip ':'
      let lengthStr = ''
      while (
        index < cleanNewick.length &&
        cleanNewick[index] !== ',' &&
        cleanNewick[index] !== ')' &&
        cleanNewick[index] !== '('
      ) {
        lengthStr += cleanNewick[index]
        index++
      }
      node.branchLength = parseFloat(lengthStr) || 0
    }

    return node
  }

  try {
    return parseNode()
  } catch (error) {
    console.error('Error parsing Newick string:', error)
    return null
  }
}

// Convert TreeNode to hierarchical structure with IDs
function convertToHierarchicalTree(node: TreeNode): FlatNodeData {
  let nodeCounter = 0

  function traverse(n: TreeNode, depth: number): FlatNodeData {
    const id = `node_${nodeCounter++}`

    // Check if this node should be collapsed:
    // If it has exactly one child that is a leaf with the same name, skip the intermediate node
    if (
      n.children &&
      n.children.length === 1 &&
      (!n.children[0].children || n.children[0].children.length === 0) && // child is a leaf
      n.name === n.children[0].name && // names match
      n.children[0].accession // child has an accession
    ) {
      // Collapse: use the child's accession but keep the parent's position in tree
      return {
        id,
        name: n.name,
        accession: n.children[0].accession, // Promote child's accession
        branchLength: n.children[0].branchLength,
        children: undefined,
        depth,
        isLeaf: true,
      }
    }

    // Normal case: process children
    const childNodes: FlatNodeData[] = []
    if (n.children && n.children.length > 0) {
      for (const child of n.children) {
        childNodes.push(traverse(child, depth + 1))
      }
    }

    return {
      id,
      name: n.name,
      accession: n.accession,
      branchLength: n.branchLength,
      children: childNodes.length > 0 ? childNodes : undefined,
      depth,
      isLeaf: !n.children || n.children.length === 0,
    }
  }

  return traverse(node, 0)
}

// Render tree node recursively
function renderTreeNode(node: FlatNodeData, speciesDataMap: Map<string, SpeciesData>): string {
  const hasChildren = node.children && node.children.length > 0
  const indent = node.depth * 20
  const speciesInfo = node.accession ? speciesDataMap.get(node.accession) : undefined

  if (hasChildren) {
    // Use <details> for expandable nodes
    let html = `
      <details class="tree-node" open style="padding-left: ${indent}px;">
        <summary class="tree-summary" style="background-color: ${node.depth % 2 === 0 ? '#ffffff' : '#f9fafb'};">
          <div class="tree-content">
            <span style="color: #1f2937;">
              ${node.name || 'Unnamed'}
            </span>
    `

    if (node.name) {
      const encodedName = encodeURIComponent(node.name)
      html += `
            <a
              href="https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?searchTerm=${encodedName}&searchMode=complete+name&lock=1&unlock=1&command=search"
              target="_blank"
              rel="noopener noreferrer"
              class="tree-link"
            >
              [?]
            </a>
      `
    }

    if (speciesInfo?.commonName) {
      html += `
            <span style="color: #6b7280;">
              (${speciesInfo.commonName})
            </span>
      `
    }

    if (node.accession) {
      html += `
            <a href="/accession/${node.accession}" class="tree-link tree-link-underline">
              (info)
            </a>
            <span class="accession-badge">
              ${node.accession}
            </span>
      `
    }

    if (speciesInfo?.ncbiRefSeqCategory === 'reference genome') {
      html += `
            <span title="NCBI designated reference">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="orange" stroke="orange" stroke-width="0" style="display: inline-block; vertical-align: middle;">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
              </svg>
            </span>
      `
    }

    if (speciesInfo?.suppressed) {
      html += `
            <span title="NCBI RefSeq suppressed">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="2" style="display: inline-block; vertical-align: middle;">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </span>
      `
    }

    if (node.branchLength !== undefined && node.branchLength !== 1.0) {
      html += `
            <span style="color: #6b7280;">
              [${node.branchLength.toFixed(4)}]
            </span>
      `
    }

    html += `
          </div>
        </summary>
    `

    // Render children
    for (const child of node.children) {
      html += renderTreeNode(child, speciesDataMap)
    }

    html += `</details>`
    return html
  } else {
    // Leaf node - no details element needed
    let html = `
      <div class="tree-leaf" style="padding-left: ${indent}px; background-color: ${node.depth % 2 === 0 ? '#ffffff' : '#f9fafb'};">
        <div class="tree-content">
          <span style="margin-right: 8px;">•</span>
          <span style="color: #374151;">
            ${node.name || 'Unnamed'}
          </span>
    `

    if (node.name) {
      const encodedName = encodeURIComponent(node.name)
      html += `
          <a
            href="https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?searchTerm=${encodedName}&searchMode=complete+name&lock=1&unlock=1&command=search"
            target="_blank"
            rel="noopener noreferrer"
            class="tree-link"
          >
            [?]
          </a>
      `
    }

    if (speciesInfo?.commonName) {
      html += `
          <span style="color: #6b7280;">
            (${speciesInfo.commonName})
          </span>
      `
    }

    if (node.accession) {
      html += `
          <a href="/accession/${node.accession}" class="tree-link tree-link-underline">
            (info)
          </a>
          <span class="accession-badge">
            ${node.accession}
          </span>
      `
    }

    if (speciesInfo?.ncbiRefSeqCategory === 'reference genome') {
      html += `
          <span title="NCBI designated reference">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="orange" stroke="orange" stroke-width="0" style="display: inline-block; vertical-align: middle;">
              <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
            </svg>
          </span>
      `
    }

    if (speciesInfo?.suppressed) {
      html += `
          <span title="NCBI RefSeq suppressed">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="red" stroke-width="2" style="display: inline-block; vertical-align: middle;">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </span>
      `
    }

    if (node.branchLength !== undefined && node.branchLength !== 1.0) {
      html += `
          <span style="color: #6b7280;">
            [${node.branchLength.toFixed(4)}]
          </span>
      `
    }

    html += `
        </div>
      </div>
    `
    return html
  }
}

const { newickData, speciesData = [], header } = Astro.props

// Create a lookup map for species data by accession
const speciesDataMap = new Map<string, SpeciesData>()
speciesData.forEach(species => {
  speciesDataMap.set(species.accession, species)
})

// Parse and convert tree
let tree: FlatNodeData | null = null
let error: string | null = null

try {
  const parsedTree = parseNewick(newickData)
  if (!parsedTree) {
    error = 'Failed to parse Newick data'
  } else {
    tree = convertToHierarchicalTree(parsedTree)
  }
} catch (err) {
  error = `Error parsing tree: ${err}`
  console.error('Tree parsing error:', err)
}

// Count accessions
function countAccessions(node: FlatNodeData | null): number {
  if (!node) return 0
  let count = node.accession ? 1 : 0
  if (node.children) {
    for (const child of node.children) {
      count += countAccessions(child)
    }
  }
  return count
}

const accessionCount = tree ? countAccessions(tree) : 0
const treeHtml = tree ? renderTreeNode(tree, speciesDataMap) : ''
---

{error ? (
  <div style="padding: 16px; border: 1px solid #fca5a5; background-color: #fef2f2; border-radius: 4px;">
    <h3 style="color: #991b1b; font-weight: 600; margin-bottom: 8px;">
      Error loading phylogenetic tree
    </h3>
    <p style="color: #dc2626;">{error}</p>
  </div>
) : !tree ? (
  <div style="padding: 16px; border: 1px solid #d1d5db; background-color: #f9fafb; border-radius: 4px;">
    <p>Loading phylogenetic tree...</p>
  </div>
) : (
  <div style="padding: 16px;">
    <div style="margin-bottom: 16px; display: flex; gap: 8px; align-items: baseline; flex-wrap: wrap;">
      {header && <div set:html={header} />}
      <div style={`${header ? 'margin-left: auto;' : ''} display: flex; gap: 8px; align-items: center; flex-wrap: wrap;`}>
        <div style="color: #6b7280;">{accessionCount} accessions</div>
      </div>
    </div>
    <div
      id="taxonomy-tree"
      style="border: 1px solid #d1d5db; border-radius: 4px; overflow-y: auto; max-height: 600px;"
      set:html={treeHtml}
    />
  </div>
)}


<style>
  /* Pure CSS tree styles */
  .tree-node {
    margin: 0;
    padding-left: 0;
  }

  .tree-summary {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid #e5e7eb;
    cursor: pointer;
    list-style: none;
  }

  .tree-summary::-webkit-details-marker {
    display: none;
  }

  .tree-summary::marker {
    display: none;
  }

  .tree-summary:hover {
    background-color: #f3f4f6 !important;
  }

  .tree-content {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
  }

  .tree-leaf {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid #e5e7eb;
  }

  .tree-leaf:hover {
    background-color: #f3f4f6 !important;
  }

  .tree-link {
    color: #2563eb;
    text-decoration: none;
  }

  .tree-link-underline {
    text-decoration: underline;
  }

  .accession-badge {
    color: #2563eb;
    background-color: #eff6ff;
    padding: 2px 6px;
    border-radius: 4px;
  }

  /* Add chevron indicator using CSS */
  .tree-summary::before {
    content: '▶';
    display: inline-block;
    margin-right: 8px;
    transition: transform 0.2s;
  }

  details[open] > .tree-summary::before {
    transform: rotate(90deg);
  }
</style>
