---
import fs from 'fs'
import path from 'path'
import TreeNode from './TreeNode.astro'

interface SpeciesData {
  accession: string
  commonName?: string
  scientificName?: string
  ncbiRefSeqCategory?: string
  suppressed?: boolean
  [key: string]: any
}

interface Props {
  category?: string
  speciesData?: SpeciesData[]
  autoShow?: boolean
  title?: string
  hubsLink?: string
  filterTaxonId?: string
}

interface TreeNode {
  name?: string
  accession?: string
  taxonId?: string
  children?: TreeNode[]
  branchLength?: number
  parent?: TreeNode
}

interface FlatNodeData {
  id: string
  name?: string
  accession?: string
  taxonId?: string
  branchLength?: number
  children?: FlatNodeData[]
  depth: number
  isLeaf: boolean
}

const {
  category = 'all',
  speciesData = [],
  autoShow = false,
  title,
  hubsLink,
  filterTaxonId,
} = Astro.props

// Read the newick file at build time
const newickPath = path.join(process.cwd(), 'public', 'taxonomy', `${category}.newick`)
let newickData = ''
let fileError: string | null = null

try {
  newickData = fs.readFileSync(newickPath, 'utf-8')
} catch (err) {
  fileError = `Failed to read taxonomy file: ${err}`
  console.error(fileError)
}

// Simple Newick parser
function parseNewick(newick: string): TreeNode | null {
  const cleanNewick = newick.trim().replace(/;$/, '')
  if (!cleanNewick) return null

  let index = 0

  function parseNode(): TreeNode {
    const node: TreeNode = { children: [] }

    if (cleanNewick[index] === '(') {
      index++ // skip '('
      do {
        const child = parseNode()
        child.parent = node
        node.children!.push(child)
        if (cleanNewick[index] === ',') {
          index++ // skip ','
        }
      } while (
        cleanNewick[index] === ',' ||
        (cleanNewick[index] !== ')' && index < cleanNewick.length)
      )
      if (cleanNewick[index] === ')') {
        index++ // skip ')'
      }
    }

    // Parse node name
    let name = ''
    while (
      index < cleanNewick.length &&
      cleanNewick[index] !== ',' &&
      cleanNewick[index] !== ')' &&
      cleanNewick[index] !== '(' &&
      cleanNewick[index] !== ':'
    ) {
      name += cleanNewick[index]
      index++
    }

    if (name) {
      const accessionMatch = name.match(/^(.+?)\[([^\]]+)\]$/)
      if (accessionMatch) {
        node.name = accessionMatch[1]
        const bracketContent = accessionMatch[2]
        // Check if bracket content contains taxonId (format: accession|taxonId)
        if (bracketContent.includes('|')) {
          const [accession, taxonId] = bracketContent.split('|')
          node.accession = accession
          node.taxonId = taxonId
        } else {
          node.accession = bracketContent
        }
      } else {
        node.name = name
      }
    }

    // Parse branch length
    if (cleanNewick[index] === ':') {
      index++ // skip ':'
      let lengthStr = ''
      while (
        index < cleanNewick.length &&
        cleanNewick[index] !== ',' &&
        cleanNewick[index] !== ')' &&
        cleanNewick[index] !== '('
      ) {
        lengthStr += cleanNewick[index]
        index++
      }
      node.branchLength = parseFloat(lengthStr) || 0
    }

    return node
  }

  try {
    return parseNode()
  } catch (error) {
    console.error('Error parsing Newick string:', error)
    return null
  }
}

// Convert TreeNode to hierarchical structure with IDs
function convertToHierarchicalTree(node: TreeNode): FlatNodeData {
  let nodeCounter = 0

  function traverse(n: TreeNode, depth: number): FlatNodeData {
    const id = `node_${nodeCounter++}`

    // Check if this node should be collapsed:
    // If it has exactly one child that is a leaf with the same name, skip the intermediate node
    if (
      n.children &&
      n.children.length === 1 &&
      (!n.children[0].children || n.children[0].children.length === 0) && // child is a leaf
      n.name === n.children[0].name && // names match
      n.children[0].accession // child has an accession
    ) {
      // Collapse: use the child's accession but keep the parent's position in tree
      return {
        id,
        name: n.name,
        accession: n.children[0].accession, // Promote child's accession
        taxonId: n.children[0].taxonId, // Promote child's taxonId
        branchLength: n.children[0].branchLength,
        children: undefined,
        depth,
        isLeaf: true,
      }
    }

    // Normal case: process children
    const childNodes: FlatNodeData[] = []
    if (n.children && n.children.length > 0) {
      for (const child of n.children) {
        childNodes.push(traverse(child, depth + 1))
      }
    }

    return {
      id,
      name: n.name,
      accession: n.accession,
      taxonId: n.taxonId,
      branchLength: n.branchLength,
      children: childNodes.length > 0 ? childNodes : undefined,
      depth,
      isLeaf: !n.children || n.children.length === 0,
    }
  }

  return traverse(node, 0)
}

// Count accessions
function countAccessions(node: FlatNodeData | null): number {
  if (!node) return 0
  let count = node.accession ? 1 : 0
  if (node.children) {
    for (const child of node.children) {
      count += countAccessions(child)
    }
  }
  return count
}

// Enumerate all unique taxonIds from the tree
function enumerateTaxonIds(node: FlatNodeData | null): Set<string> {
  const taxonIds = new Set<string>()

  function traverse(n: FlatNodeData | null) {
    if (!n) return
    if (n.taxonId) {
      taxonIds.add(n.taxonId)
    }
    if (n.children) {
      for (const child of n.children) {
        traverse(child)
      }
    }
  }

  traverse(node)
  return taxonIds
}

// Extract subtree for a specific taxonId
function extractSubtreeByTaxonId(node: FlatNodeData | null, targetTaxonId: string): FlatNodeData | null {
  if (!node) return null

  // Check if current node matches the taxonId
  if (node.taxonId === targetTaxonId) {
    return node
  }

  // Check if any child matches
  if (node.children) {
    for (const child of node.children) {
      const result = extractSubtreeByTaxonId(child, targetTaxonId)
      if (result) return result
    }
  }

  return null
}

// Create a lookup map for species data by accession
const speciesDataMap = new Map<string, SpeciesData>()
speciesData.forEach(species => {
  speciesDataMap.set(species.accession, species)
})

// Parse and convert tree
let tree: FlatNodeData | null = null
let parseError: string | null = null

if (!fileError && newickData) {
  try {
    const parsedTree = parseNewick(newickData)
    if (!parsedTree) {
      parseError = 'Failed to parse Newick data'
    } else {
      tree = convertToHierarchicalTree(parsedTree)

      // If filterTaxonId is provided, extract the subtree for that taxonId
      if (filterTaxonId && tree) {
        tree = extractSubtreeByTaxonId(tree, filterTaxonId)
        if (!tree) {
          parseError = `No subtree found for taxonomy ID: ${filterTaxonId}`
        }
      }
    }
  } catch (err) {
    parseError = `Error parsing tree: ${err}`
    console.error('Tree parsing error:', err)
  }
}

const accessionCount = tree ? countAccessions(tree) : 0
const error = fileError || parseError
---

<div id="taxonomy-tree-container">
  {!autoShow && (
    <button id="show-taxonomy-btn" class="show-tree-btn">Show taxonomy</button>
  )}
  <div id="taxonomy-tree-content" style={autoShow ? '' : 'display: none;'}>
    {error ? (
      <div style="padding: 16px; border: 1px solid #fca5a5; background-color: #fef2f2; border-radius: 4px;">
        <h3 style="color: #991b1b; font-weight: 600; margin-bottom: 8px;">
          Error loading taxonomy
        </h3>
        <p style="color: #dc2626;">{error}</p>
      </div>
    ) : !tree ? (
      <div style="padding: 16px; border: 1px solid #d1d5db; background-color: #f9fafb; border-radius: 4px;">
        <p>Loading taxonomy...</p>
      </div>
    ) : (
      <div style="padding: 16px;">
        <div style="margin-bottom: 16px; display: flex; gap: 8px; align-items: baseline; flex-wrap: wrap;">
          {title && hubsLink && (
            <>
              <h1 style="margin: 0;">GenArk taxonomy - {title}</h1>
              <a href={hubsLink} style="color: #2563eb; text-decoration: underline;">
                View list of species as table for {title}
              </a>
            </>
          )}
          <div style={`${title && hubsLink ? 'margin-left: auto;' : ''} display: flex; gap: 8px; align-items: center; flex-wrap: wrap;`}>
            <div style="color: #6b7280;">{accessionCount} accessions</div>
          </div>
        </div>
        
        {tree && <TreeNode node={tree} speciesDataMap={speciesDataMap} />}
      </div>
    )}
  </div>
</div>

{!autoShow && (
  <script>
    const showBtn = document.getElementById('show-taxonomy-btn')
    const content = document.getElementById('taxonomy-tree-content')

    if (showBtn && content) {
      showBtn.addEventListener('click', () => {
        content.style.display = 'block'
        showBtn.style.display = 'none'
      })
    }
  </script>
)}


<style>
  .show-tree-btn {
    padding: 8px 16px;
    background-color: #2563eb;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
  }

  .show-tree-btn:hover {
    background-color: #1d4ed8;
  }

  /* Pure CSS tree styles */
  .tree-node {
    margin: 0;
    padding-left: 0;
  }

  .tree-summary {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid #e5e7eb;
    cursor: pointer;
    list-style: none;
  }

  .tree-summary::-webkit-details-marker {
    display: none;
  }

  .tree-summary::marker {
    display: none;
  }

  .tree-summary:hover {
    background-color: #f3f4f6 !important;
  }

  .tree-content {
    display: inline;
  }

  .tree-content > * {
    display: inline;
    margin-right: 8px;
  }

  .tree-leaf {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid #e5e7eb;
  }

  .tree-leaf:hover {
    background-color: #f3f4f6 !important;
  }

  .tree-link {
    color: #2563eb;
    text-decoration: none;
  }

  .tree-link-underline {
    text-decoration: underline;
  }

  .accession-badge {
    color: #2563eb;
    background-color: #eff6ff;
    padding: 2px 6px;
    border-radius: 4px;
  }

  /* Add chevron indicator using CSS */
  .tree-summary::before {
    content: 'X';
    display: inline-block;
    margin-right: 8px;
    transition: transform 0.2s;
  }

  details[open] > .tree-summary::before {
    transform: rotate(90deg);
  }
</style>
