---
import fs from 'fs'
import path from 'path'
import TreeNode from './TreeNode.astro'

interface SpeciesData {
  accession: string
  commonName?: string
  scientificName?: string
  ncbiRefSeqCategory?: string
  suppressed?: boolean
  [key: string]: any
}

interface Props {
  category?: string
  speciesData?: SpeciesData[]
  title?: string
  hubsLink?: string
  filterTaxonId?: string
}

interface TreeNode {
  name?: string
  accession?: string
  taxonId?: string
  children?: TreeNode[]
  branchLength?: number
  parent?: TreeNode
}

interface FlatNodeData {
  id: string
  name?: string
  accession?: string
  taxonId?: string
  branchLength?: number
  children?: FlatNodeData[]
  depth: number
  isLeaf: boolean
}

const {
  category = 'all',
  speciesData = [],
  title,
  hubsLink,
  filterTaxonId,
} = Astro.props

// Read the newick file at build time
const newickPath = path.join(
  process.cwd(),
  'public',
  'taxonomy',
  `${category}.newick`,
)
let newickData = ''
let fileError: string | null = null

try {
  newickData = fs.readFileSync(newickPath, 'utf-8')
} catch (err) {
  fileError = `Failed to read taxonomy file: ${err}`
  console.error(fileError)
}

// Simple Newick parser
function parseNewick(newick: string): TreeNode | null {
  const cleanNewick = newick.trim().replace(/;$/, '')
  if (!cleanNewick) return null

  let index = 0

  function parseNode(): TreeNode {
    const node: TreeNode = { children: [] }

    if (cleanNewick[index] === '(') {
      index++ // skip '('
      do {
        const child = parseNode()
        child.parent = node
        node.children!.push(child)
        if (cleanNewick[index] === ',') {
          index++ // skip ','
        }
      } while (
        cleanNewick[index] === ',' ||
        (cleanNewick[index] !== ')' && index < cleanNewick.length)
      )
      if (cleanNewick[index] === ')') {
        index++ // skip ')'
      }
    }

    // Parse node name
    let name = ''
    while (
      index < cleanNewick.length &&
      cleanNewick[index] !== ',' &&
      cleanNewick[index] !== ')' &&
      cleanNewick[index] !== '(' &&
      cleanNewick[index] !== ':'
    ) {
      name += cleanNewick[index]
      index++
    }

    if (name) {
      // First check for leaf node format: Name[accession|taxonId]
      const accessionMatch = name.match(/^(.+?)\[([^\]]+)\]$/)
      if (accessionMatch) {
        node.name = accessionMatch[1]
        const bracketContent = accessionMatch[2]
        // Check if bracket content contains taxonId (format: accession|taxonId)
        if (bracketContent.includes('|')) {
          const [accession, taxonId] = bracketContent.split('|')
          node.accession = accession
          node.taxonId = taxonId
        } else {
          node.accession = bracketContent
        }
      } else {
        // Check for internal node format: Name{taxonId}
        const internalMatch = name.match(/^(.+?)\{([^\}]+)\}$/)
        if (internalMatch) {
          node.name = internalMatch[1]
          node.taxonId = internalMatch[2]
        } else {
          node.name = name
        }
      }
    }

    // Parse branch length
    if (cleanNewick[index] === ':') {
      index++ // skip ':'
      let lengthStr = ''
      while (
        index < cleanNewick.length &&
        cleanNewick[index] !== ',' &&
        cleanNewick[index] !== ')' &&
        cleanNewick[index] !== '('
      ) {
        lengthStr += cleanNewick[index]
        index++
      }
      node.branchLength = parseFloat(lengthStr) || 0
    }

    return node
  }

  try {
    return parseNode()
  } catch (error) {
    console.error('Error parsing Newick string:', error)
    return null
  }
}

// Convert TreeNode to hierarchical structure with IDs
function convertToHierarchicalTree(node: TreeNode): FlatNodeData {
  let nodeCounter = 0

  function traverse(n: TreeNode, depth: number): FlatNodeData {
    const id = `node_${nodeCounter++}`

    // Check if this node should be collapsed:
    // If it has exactly one child that is a leaf with the same name, skip the intermediate node
    if (
      n.children &&
      n.children.length === 1 &&
      (!n.children[0].children || n.children[0].children.length === 0) && // child is a leaf
      n.name === n.children[0].name && // names match
      n.children[0].accession // child has an accession
    ) {
      // Collapse: use the child's accession but keep the parent's position in tree
      return {
        id,
        name: n.name,
        accession: n.children[0].accession, // Promote child's accession
        taxonId: n.children[0].taxonId, // Promote child's taxonId
        branchLength: n.children[0].branchLength,
        children: undefined,
        depth,
        isLeaf: true,
      }
    }

    // Normal case: process children
    const childNodes: FlatNodeData[] = []
    if (n.children && n.children.length > 0) {
      for (const child of n.children) {
        childNodes.push(traverse(child, depth + 1))
      }
    }

    return {
      id,
      name: n.name,
      accession: n.accession,
      taxonId: n.taxonId,
      branchLength: n.branchLength,
      children: childNodes.length > 0 ? childNodes : undefined,
      depth,
      isLeaf: !n.children || n.children.length === 0,
    }
  }

  return traverse(node, 0)
}

// Count accessions
function countAccessions(node: FlatNodeData | null): number {
  if (!node) return 0
  let count = node.accession ? 1 : 0
  if (node.children) {
    for (const child of node.children) {
      count += countAccessions(child)
    }
  }
  return count
}

// Enumerate all unique taxonIds from the tree
function enumerateTaxonIds(node: FlatNodeData | null): Set<string> {
  const taxonIds = new Set<string>()

  function traverse(n: FlatNodeData | null) {
    if (!n) return
    if (n.taxonId) {
      taxonIds.add(n.taxonId)
    }
    if (n.children) {
      for (const child of n.children) {
        traverse(child)
      }
    }
  }

  traverse(node)
  return taxonIds
}

// Extract subtree for a specific taxonId
function extractSubtreeByTaxonId(
  node: FlatNodeData | null,
  targetTaxonId: string,
): FlatNodeData | null {
  if (!node) return null

  // Check if current node matches the taxonId
  if (node.taxonId === targetTaxonId) {
    return node
  }

  // Check if any child matches
  if (node.children) {
    for (const child of node.children) {
      const result = extractSubtreeByTaxonId(child, targetTaxonId)
      if (result) return result
    }
  }

  return null
}

// Extract lineage (path from root to target node)
function extractLineageByTaxonId(
  node: FlatNodeData | null,
  targetTaxonId: string,
): FlatNodeData[] {
  if (!node) return []

  // Check if current node matches the taxonId
  if (node.taxonId === targetTaxonId) {
    return [node]
  }

  // Check if any child's lineage contains the target
  if (node.children) {
    for (const child of node.children) {
      const childLineage = extractLineageByTaxonId(child, targetTaxonId)
      if (childLineage.length > 0) {
        // Found it! Prepend current node to the lineage
        return [node, ...childLineage]
      }
    }
  }

  return []
}

// Create a lookup map for species data by accession
const speciesDataMap = new Map<string, SpeciesData>()
speciesData.forEach(species => {
  speciesDataMap.set(species.accession, species)
})

// Parse and convert tree
let tree: FlatNodeData | null = null
let lineage: FlatNodeData[] = []
let parseError: string | null = null

if (!fileError && newickData) {
  try {
    const parsedTree = parseNewick(newickData)
    if (!parsedTree) {
      parseError = 'Failed to parse Newick data'
    } else {
      tree = convertToHierarchicalTree(parsedTree)

      // If filterTaxonId is provided, extract the lineage and subtree for that taxonId
      if (filterTaxonId && tree) {
        // Extract lineage first (before extracting subtree)
        lineage = extractLineageByTaxonId(tree, filterTaxonId)

        // Then extract the subtree
        tree = extractSubtreeByTaxonId(tree, filterTaxonId)
        if (!tree) {
          parseError = `No subtree found for taxonomy ID: ${filterTaxonId}`
        }
      }
    }
  } catch (err) {
    parseError = `Error parsing tree: ${err}`
    console.error('Tree parsing error:', err)
  }
}

const accessionCount = tree ? countAccessions(tree) : 0
const error = fileError || parseError
---

<div id="taxonomy-tree-container">
  <div id="taxonomy-tree-content">
    {error ? (
      <div style="padding: 16px; border: 1px solid #fca5a5; background-color: #fef2f2; border-radius: 4px;">
        <h3 style="color: #991b1b; font-weight: 600; margin-bottom: 8px;">
          Error loading taxonomy
        </h3>
        <p style="color: #dc2626;">{error}</p>
      </div>
    ) : !tree ? (
      <div style="padding: 16px; border: 1px solid #d1d5db; background-color: #f9fafb; border-radius: 4px;">
        <p>Loading taxonomy...</p>
      </div>
    ) : (
      <div style="padding: 16px;">
        <div style="margin-bottom: 16px; display: flex; gap: 8px; align-items: baseline; flex-wrap: wrap;">
          {title && hubsLink ? (
            <>
              <h1 style="margin: 0;">GenArk taxonomy - {title}</h1>
              <a
                href={hubsLink}
                style="color: #2563eb; text-decoration: underline;"
              >
                View list of species as table for {title}
              </a>
            </>
          ) : null}
          <div
            style={`${title && hubsLink ? 'margin-left: auto;' : ''} display: flex; gap: 8px; align-items: center; flex-wrap: wrap;`}
          >
            <div style="color: #6b7280;">{accessionCount} accessions</div>
          </div>
        </div>

        {lineage.length > 0 ? (
          <div class="lineage-container">
            <div class="lineage-label">Taxonomy:</div>
            <div class="lineage-breadcrumbs">
              {lineage.slice(0, -1).map((node, index) => (
                <>
                  <a
                    href={`/taxonomy/${node.taxonId}`}
                    class="lineage-link"
                  >
                    {node.name || 'Unnamed'}
                  </a>
                  <span class="lineage-separator">â€º</span>
                </>
              ))}
              <span class="lineage-current">
                {lineage[lineage.length - 1]?.name || 'Unnamed'}
              </span>
            </div>
          </div>
        ) : null}

        {filterTaxonId ? (
          <div class="taxonomy-info-container">
            <div class="taxonomy-info-label">Taxonomy information:</div>
            <a
              href={`https://www.ncbi.nlm.nih.gov/datasets/taxonomy/${filterTaxonId}/`}
              target="_blank"
              rel="noopener noreferrer"
              class="taxonomy-info-link"
            >
              View on NCBI (taxonomy ID: {filterTaxonId})
              <svg
                width="12"
                height="12"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
                style="display: inline-block; vertical-align: middle; margin-left: 4px;"
              >
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" />
                <polyline points="15 3 21 3 21 9" />
                <line x1="10" y1="14" x2="21" y2="3" />
              </svg>
            </a>
          </div>
        ) : null}

        {tree ? (
          <TreeNode node={tree} speciesDataMap={speciesDataMap} />
        ) : null}
      </div>
    )}
  </div>
</div>

<style>
  .lineage-container {
    background-color: #f9fafb;
    border: 1px solid #e5e7eb;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .lineage-label {
    font-weight: 600;
    color: #374151;
    font-size: 14px;
  }

  .lineage-breadcrumbs {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 8px;
    font-size: 14px;
  }

  .lineage-link {
    color: #2563eb;
    text-decoration: none;
    transition: color 0.2s;
  }

  .lineage-link:hover {
    color: #1d4ed8;
    text-decoration: underline;
  }

  .lineage-separator {
    color: #9ca3af;
    user-select: none;
  }

  .lineage-current {
    color: #1f2937;
    font-weight: 600;
  }

  .taxonomy-info-container {
    background-color: #eff6ff;
    border: 1px solid #bfdbfe;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 16px;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }

  .taxonomy-info-label {
    font-weight: 600;
    color: #1e40af;
    font-size: 14px;
  }

  .taxonomy-info-link {
    color: #2563eb;
    text-decoration: none;
    font-size: 14px;
    display: inline-flex;
    align-items: center;
    transition: color 0.2s;
  }

  .taxonomy-info-link:hover {
    color: #1d4ed8;
    text-decoration: underline;
  }

  /* Pure CSS tree styles */
  .tree-node {
    margin: 0;
    padding-left: 0;
  }

  .tree-summary {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid #e5e7eb;
    cursor: pointer;
    list-style: none;
  }

  .tree-summary::-webkit-details-marker {
    display: none;
  }

  .tree-summary::marker {
    display: none;
  }

  .tree-summary:hover {
    background-color: #f3f4f6 !important;
  }

  .tree-content {
    display: inline;
  }

  .tree-content > * {
    display: inline;
    margin-right: 8px;
  }

  .tree-leaf {
    display: flex;
    align-items: center;
    padding: 8px 16px;
    border-bottom: 1px solid #e5e7eb;
  }

  .tree-leaf:hover {
    background-color: #f3f4f6 !important;
  }

  .tree-link {
    color: #2563eb;
    text-decoration: none;
  }

  .tree-link-underline {
    text-decoration: underline;
  }

  .accession-badge {
    color: #2563eb;
    background-color: #eff6ff;
    padding: 2px 6px;
    border-radius: 4px;
  }

  /* Add chevron indicator using CSS */
  .tree-summary::before {
    content: 'X';
    display: inline-block;
    margin-right: 8px;
    transition: transform 0.2s;
  }

  details[open] > .tree-summary::before {
    transform: rotate(90deg);
  }
</style>
